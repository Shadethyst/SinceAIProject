# -*- coding: utf-8 -*-
"""EISKO_crop.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12ajg21wVQqr5U2IueznnnZ-ComoPYfZJ
"""

from google.colab import drive
# Mount Google Drive to access files
drive.mount('/content/drive')

!pip install pdf2image

# Install poppler-utils for pdf2image to function correctly
!apt-get install poppler-utils

# import module
from pdf2image import convert_from_path
from PIL import Image, ImageEnhance
import cv2
import numpy as np
import matplotlib.pyplot as plt

# The path to PDF file from Google Drive is:
pdf_file_path = "/content/drive/MyDrive/Copy of Laskentatiedosto_KisaÌˆlli PK-KK 31.1.2025.pdf"

# Store Pdf with convert_from_path function
images = convert_from_path(pdf_file_path)

for i in range(len(images)):
      # Save pages as images in the pdf
    images[i].save('page'+ str(i) +'.jpg', 'JPEG')

img = Image.open(str(f"page{1}.jpg"))

"""CROPPING THE DESIRED AREA

Input: image

Output: image (cropped, non-standard size)
"""

def crop_eisko(img):

  # Convert PIL Image to NumPy array for OpenCV operations.
  # PIL Image.open loads images in RGB format by default.
  img_np_rgb = np.array(img)

  # Convert to grayscale
  # Since img_np_rgb is RGB, convert from RGB to GRAY.
  test_img_gray = cv2.cvtColor(img_np_rgb, cv2.COLOR_RGB2GRAY)

  # Step 1: Apply edge detection (Canny Edge)
  edges = cv2.Canny(test_img_gray, 50, 150)

  # Step 2: Detect lines using Hough Line Transform
  lines = cv2.HoughLinesP(edges, 1, np.pi / 180, 100, minLineLength=350, maxLineGap=10)

  # Step 3: Filter out vertical lines (lines with nearly vertical slope)
  vertical_lines = []
  coord_vertical_lines = []
  coord_horizontal_lines = []
  if lines is not None: # It's good practice to check if lines were found
      for line_coords in lines:
          x1, y1, x2, y2 = line_coords[0]
          # A vertical line should have x1 close to x2.
          # The condition abs(x2 - x1) < 10 checks for vertical lines.
          if abs(x2 - x1) < 10:
              vertical_lines.append((x1, y1, x2, y2))
              coord_vertical_lines.append((x1, y1, x2, y2))
          else :
              coord_horizontal_lines.append((x1, y1, x2, y2))

  # Step 4: Check for lines that are close together
  close_lines = []
  threshold = 30
  threshold2 = 10
  for i in range(len(vertical_lines)-1):
      for j in range(i + 2, len(vertical_lines)):
          x1_a, _, y1_a, _ = vertical_lines[i] # Get x-coordinate of the first line
          x1_b, _, y1_b, y2_b = vertical_lines[j] # Get x-coordinate of the second line
          if (y1_a - y2_b) < 0:
            if abs(x1_a - x1_b) < threshold: # Compare x-coordinates of the lines
              if abs(x1_a - x1_b) > threshold2: # Compare x-coordinates of the lines
                  close_lines.append((vertical_lines[i], vertical_lines[j]))

  # Find the edges of the croppee area
  alkupiste_hor = close_lines[0][0][0]
  alkupiste_ver = close_lines[0][0][1]
  loppupiste_hor = close_lines[0][0][2]
  loppupiste_ver = close_lines[0][0][3]
  ylaraja = img.size[1]
  alaraja = 0
  vasenraja = 0
  oikearaja = img.size[0]
  paatepisteet = (alkupiste_hor, alkupiste_ver, loppupiste_hor, loppupiste_ver)
  # Find the line above and below the first close line
  if lines is not None: # It's good practice to check if lines were found
      for line_coords in lines:
          x1, y1, x2, y2 = line_coords[0]
          # A vertical line should have x1 close to x2.
          # The condition abs(x2 - x1) < 10 checks for vertical lines.
          if abs(x2 - x1) < 10:
              if x1 < alkupiste_hor: # vasen puoli
                if x1 > vasenraja:
                    vasenraja = x1
              if x1 > (loppupiste_hor + 100): # oikea puoli
                if x1 < oikearaja:
                    oikearaja = x1
          else : # Line is horizontal
              if y1 > alkupiste_ver:
                if y1 < ylaraja:
                  ylaraja = y1
              if y2 < loppupiste_ver:
                if y2 > alaraja:
                  alaraja = y2
  cropped_image = img.crop((vasenraja, alaraja, oikearaja, ylaraja))

  return cropped_image

cropped = crop_eisko(img)
display(cropped)

# Step 5: Plot the result
  # Create a copy of the original RGB NumPy array to draw lines on.
img_with_lines_display = img_np_rgb.copy()

piste_a = (vasenraja, ylaraja)
piste_b = (oikearaja, alaraja)

  # Draw lines on the image. OpenCV's cv2.line works with RGB input.
  # The error 'ValueError: not enough values to unpack (expected 4, got 2)'
  # occurred because 'line' in 'for line in close_lines:' was a tuple of two line tuples,
  # not a single tuple of four coordinates.
for line_pair in close_lines:
      # Unpack the two lines from the pair
      line1_coords = line_pair[0]
      line2_coords = line_pair[1]

      # Draw line1
      x1, y1, x2, y2 = line1_coords
      cv2.line(img_with_lines_display, (x1, y1), (x2, y2), (255, 0, 0), 2) # Red line in RGB

      # Draw line2
      x1, y1, x2, y2 = line2_coords
      cv2.line(img_with_lines_display, (x1, y1), (x2, y2), (0, 255, 0), 2) # Green line in RGB

  # Visualize the result using matplotlib. Matplotlib expects RGB.
plt.figure(figsize=(10, 10))
plt.imshow(img_with_lines_display) # Display the image which is already in RGB
plt.plot(piste_a[0],piste_a[1],'bo')
plt.plot(piste_b[0], piste_b[1],'ro')
plt.axis('off')
plt.show()

  # Optionally, print or return the close lines detected
print("Close lines detected:", len(close_lines))
print("Close lines detected:", close_lines)
print("First close line: ", close_lines[0][0][0])
print("Number of vertical lines detected:", len(vertical_lines))