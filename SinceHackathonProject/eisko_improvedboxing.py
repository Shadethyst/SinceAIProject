# -*- coding: utf-8 -*-
"""EISKO_improvedBoxing.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LddcR0rN9xY3Xu90pWKV4EzysZfrIe0b
"""

## Improved boxing ##
#### Bounding boxes: Clustering  #####

import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import AgglomerativeClustering
from PIL import Image # Ensure PIL Image is imported if not already

# Load the image
img = img_symbols

# Convert PIL Image to NumPy array and then to grayscale
# PIL images are usually RGB, so convert from RGB to GRAY
gray = cv2.cvtColor(np.array(img), cv2.COLOR_RGB2GRAY)

# Apply thresholding to get a binary image (white objects on black background)
_, thresh = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)

# Find contours (mode is RETR_EXTERNAL, method is CHAIN_APPROX_SIMPLE)
contours, hierarchy = cv2.findContours(thresh, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)

# Centroids, filtering
bounding_boxes = []  # list of (x, y, w, h)
centroids = []       # centroids for clustering
filtered_contours = []  # contours that pass the size filter

max_width = 200    # adjust
max_height = 200
max_area = 20000   # optional

for cnt in contours:
    x, y, w, h = cv2.boundingRect(cnt)
    area = w * h

    # Filter here: only keep boxes below thresholds
    if w < max_width and h < max_height and area < max_area:
        filtered_contours.append(cnt)
        # store centroid
        cx = x + w // 2
        cy = y + h // 2
        centroids.append([cx, cy])

centroids = np.array(centroids)
cl_treshold = 80
# Step 2: Apply Agglomerative Clustering to group the centroids
agg_clustering = AgglomerativeClustering(n_clusters=None, distance_threshold=cl_treshold)
labels = agg_clustering.fit_predict(centroids)

# Step 3: Draw bounding boxes around each cluster
# Convert PIL Image to NumPy array for OpenCV drawing operations
img_with_boxes = np.array(img.copy())
# Convert to BGR format for OpenCV drawing (if image is RGB initially)
img_with_boxes = cv2.cvtColor(img_with_boxes, cv2.COLOR_RGB2BGR)

# For each cluster, find all contours in that cluster and draw the bounding box
unique_labels = set(labels)

for label in unique_labels:
    if label == -1:
        continue  # Skip noise points if they exist (not applicable in AgglomerativeClustering, no noise by default)

    # Find all contours belonging to this label
    cluster_contours = [filtered_contours[i] for i in range(len(filtered_contours)) if labels[i] == label]

    # Combine bounding boxes of all contours in the cluster
    # The previous error occurred here, attempting to use cv2.boundingRect on stacked (x,y,w,h) tuples.
    # Instead, we will directly compute the overall bounding box from individual contour bounding boxes.
    if cluster_contours:
        all_x = [cv2.boundingRect(c)[0] for c in cluster_contours]
        all_y = [cv2.boundingRect(c)[1] for c in cluster_contours]
        all_w = [cv2.boundingRect(c)[2] for c in cluster_contours]
        all_h = [cv2.boundingRect(c)[3] for c in cluster_contours]

        min_x = min(all_x)
        min_y = min(all_y)
        max_x = max([x + w for x, w in zip(all_x, all_w)])
        max_y = max([y + h for y, h in zip(all_y, all_h)])

        # Append the bounding box to the list in (x, y, w, h) format
        bounding_boxes.append((min_x, min_y, max_x - min_x, max_y - min_y))

        # Draw the bounding box around the cluster of contours on the image
        cv2.rectangle(img_with_boxes, (min_x, min_y), (max_x, max_y), (0, 255, 0), 2)  # Green rectangle


## OUTPUT: bounding_boxes
### END OF CLUSTERS ###